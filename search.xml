<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MVP模式探讨]]></title>
    <url>%2F2018%2F02%2F24%2Fmvp%2F</url>
    <content type="text"><![CDATA[前言 决定重写捋一遍android的各个技术点，常用的模式框架等等，就从这第一篇开始吧！ MVP模式到底是什么？ 个人理解MVP模式就是将数据层与视图层彻底分离，增加耦合性，简洁代码，缺点就是随之会增加很多类、接口文件。 不过。。。跟现在项目的0框架相比真的舒服很多了。 简单描述 MVP顾名思义就是分为 M层、 V层、 P层 ， M层是数据层，负责开启网络请求或者从数据库等拉取数据， V层是视图层，用于渲染界面展示视图的，而P层就在这两个层之间充当桥梁，连接这两个层，至此，M层与V层相互独立，通过一个P层，视图层专心渲染视图，数据层专心拉取数据，分工明确。 大致的流程是这样的： 首先，在V层中， V层需要告诉P层，V： P层，我需要XXX数据，你给我赶紧弄过来。 P层听到V层于是就告诉M层， P： M层，V告诉我他要XXX数据了，你赶紧的吧，好了告诉我啊。 于是，M层就开始开启网络请求拉取数据了，成功或者失败都会告诉P层。 在P层中这时候已经拿到M层返回的结果了，这时候P会通过接口回调返回给V层。 我们简单的看下一个代码， 业务大致就是一个页面请求列表数据，用MVP模式改造如下： View层告诉P层，我想看最近热映的十部电影都有哪些 //View层 public class MovieActivity implements IMovieView{ .... MoviePresenter mMoviePresenter; @Override public void onCreate(Bundle savedInstanceState) { mMoviePresenter = new MoviePresenter(this);//构造方法的参数为IView接口 mMoviePresenter.getPlayingMovie(10); } .... } P层告诉M层， V他要看最近的十部电影，你给我弄过来 Presenter层 public class MoviePresenter { private IMovieView mIView; public MoviePresenter(IMovieView iMovieView) { mIView = iMovieView } //获取正在上映的电影 public void getPlayingMovie(int count) { //通知M层开启请求 MovieModel.getInstance.getPlayingMovie(count, ...); } .... } M层开始网络请求数据，返回数据通知P层 //Model层 public class MovieModel { ... //开启网络请求获取正在上映的电影 public void getPlayingMovie(int count, HttpObserver&lt;List&lt;MovieRes&gt;&gt; observer, PublishSubject&lt;LifeCycleEvent&gt; lifecycleSubject) { //开启网络请求，结果返回后通过传入的observer回调给P层 Observable observable = RetrofitUtil.getApiService().getPlayingMovie(count); RetrofitUtil.composeToSubscribe(observable, observer, lifecycleSubject); } } P层拿到M层返回的数据通过接口回调返回给V层 ，整个过程结束。 //Presenter层 public class MoviePresenter { .... //获取正在上映的电影 public void getPlayingMovie(int count) { //通知M层开启请求 MovieModel.getInstance.getPlayingMovie(count, new HttpObserver&lt;List&lt;MovieRes&gt;&gt;() { @Override public void onNext(String title, List&lt;MovieRes&gt; list) { //通过接口IView将成功的结果回调给V层 if (mIView != null) { mIView.getMovieSuccess(list); } } @Override public void onError(int errType, String errMessage) { //通过接口将失败的结果回调给V层 if (mIView != null) { mIView.getMovieFail(errType, errMessage); } } }); } //IView接口代码，用于Presenter层与View层的交互 public interface IMovieView extends IBaseView { //成功获取电影数据 void getMovieSuccess(List&lt;MovieRes&gt; list); //获取电影数据失败 void getMovieFail(int status, String desc); } //View层（实现回调接口IMovieView中的方法） public class MovieActivity implements IMovieView{ ... //网络请求成功的回调 @Override public void getMovieSuccess(List&lt;MovieRes&gt; list) { if (CollectionUtil.isEmpty(list)) { //数据为空则设置页面为“无数据”状态 getLoadLayout().setLayoutState(State.NO_DATA); }else{ //设置页面为“成功”状态，显示正文布局 getLoadLayout().setLayoutState(State.SUCCESS); //列表展示数据 mMovieAdapter = new MovieAdapter(mActivity, list, this); mRvMovie.setLayoutManager(new LinearLayoutManager(getContext())); mRvMovie.setHasFixedSize(false); mRvMovie.setAdapter(mMovieAdapter); } } //网络请求失败的回调 @Override public void getMovieFail(int status, String desc) { //设置页面为“失败”状态 getLoadLayout().setLayoutState(State.FAILED); } ... } 总结 MVP模式相对于MVC模式最大的不同就是，MVC中， M层与V层是相通的，而MVP中是不相通的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android封装思想与应用]]></title>
    <url>%2F2017%2F08%2F14%2Fandroid_framwork%2F</url>
    <content type="text"><![CDATA[前言不会偷懒的程序员不是好的程序员，学会如何封装是程序员的一条必经之路，那么你真的会封装吗？接下来我们一步步来封装实现属于你自己的一个框架。 Base类都能做些什么Android中有个坑，如果应用被强杀那么Activity的栈信息将会被保存下来，下次恢复直接走到上次被强杀前的页面，这样就出现很多问题了。 善用Base类解决应用强杀造成的空指针问题。空指针场景：如果一个应用在application里初始化了一个静态变量，并且在主页赋值，第三个页面会用到这个值如果应用这时候被强杀，再次进来是直接走到第三个页面的，这时候就会造成空指针异常。这里文字描述比较苍白，可以自己写个Demo跑一遍，强杀的话就用AS中调试的结束红色按钮，然后在手机上的最近打开的应用里重新打开。 思路： 我们可以将主页Activity设置为singleTask模式，然后在每个页面启动前判断应用是否强杀，如果是的话就重新走到主页，不是的话去初始化页面。 我们在BaseActivity的onCreate方法中加入以下代码： 12345678910@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (MyApplication.AppStatus == -1) &#123; protectApp(); &#125; else &#123; setUpData(); &#125; &#125; 结合我们的第一个页面SplashActivity 123456@Override protected void onCreate(Bundle savedInstanceState) &#123; MyApplication.AppStatus = 0; super.onCreate(savedInstanceState); &#125; 在SplashActivity的初始化中将MyApplication.AppStatus原先为-1的值改为0 ,所以假设应用被强杀再次进入MyApplication.AppStatus值应该是-1 ，所以我们判断这个值就可以知道应用是否是强杀掉的。 现在回头来分析BaseActivity中的代码，假如被强杀走protectApp方法，否则走setUpData方法。那么我们知道了应用是否被强杀之后就应该告诉页面该如何执行，所以protectApp中的代码应该是将APP的页面重新走到主页去。 1234567protected void protectApp() &#123; Intent intent = new Intent(); intent.putExtra(&quot;protectApp&quot;, &quot;protect&quot;); intent.setClass(this, MainActivity.class); startActivity(intent); &#125; 到目前为止我们的每个页面只要基础自BaseActivity，就实现了在应用被强杀的时候执行protectAPP方法跳转到MainActivity中去 MainActivity由于是SingleTask模式所以会回调OnNewIntent方法，在这个方法中将页面finish并且跳转到欢迎页SplashActivity中去 那么如果当前页面就是MainActivity呢？ 如果再执行protectAPP方法就不对了，所以我们在MainActivity中去重写protectAPP方法， 123456@Override protected void protectApp() &#123; //当前页面被强杀调用 startActivity(new Intent(MainActivity.this , SplashActivity.class)); finish(); &#125; 到此为止，我们通过一个BaseActivity就解决了应用被强杀造成的空指针问题。 梳理一遍流程，当app被强杀，当前页面会被直接启动而跳过启动页，调用BaseActivity的onCreate方法，判断到是强杀于是走protectApp方法，跳转到主页， 由于主页是SingleTask模式，会回调onNewIntent方法，并且接收Intent传递的值从而知道应用被强杀了，于是主页跳转回启动页并且finish 。 这样应用在被强杀的时候总能再次打开启动页，空指针的问题就解决了。 Base类还能做些什么]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit学习分析]]></title>
    <url>%2F2017%2F07%2F31%2Fretorfit_notes%2F</url>
    <content type="text"><![CDATA[Retrofit是如何通过注解来设置okhttp的配置的呢Retrofit通过注解的方式来配置http请求，即使不用okhttp改用httpClient上层也不需要去修改。 带着多种疑问去看源码 1234567891011121314151617181920public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(&quot;Base URL required.&quot;); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 这是Retrofit中build方法，其中有一行我们看到 1234okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; 这行代码目测是忘记删了，没有对callFactory!=null的情况做处理，并且从这里我们看出Retrofit目前只支持Okhttp。 123456789101112131415161718192021222324@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(final Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancelation callback.onFailure(call, new IOException(&quot;Canceled&quot;)); &#125; else &#123; callback.onResponse(call, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(final Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(call, t); &#125; &#125;); &#125; &#125;);&#125; callbackExecutor.execute将异步从子线程切换到主线程中并回调callBack。 接着我们来看看Retrofit中个人认为最神奇的一行代码 RequestServes requestSerives = retrofit.create(RequestServes.class);这个类明明是个接口，并且我们没有实现类，Retrofit是如何生成我们的实现类的呢？这个。。。总之就是动态代理了 反正我也看不懂。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJava学习笔记]]></title>
    <url>%2F2017%2F07%2F31%2Frxjava_notes%2F</url>
    <content type="text"><![CDATA[前言之前学了一段时间的RxJava，由于项目中没用到过，回头看居然又忘了，索性今天再去捋一遍吧。注：只记录学习笔记，详细的不赘述。 先贴上个人觉得RxJava讲的最好的一个系列： http://www.jianshu.com/p/464fa025229e ObservableEmitter ObservableEmitter 发射器，可以发出onNext(T value)、onComplete()和onError(Throwable error)必须遵循的规则： 上游即Observable在发送onNext、 onComplete 、onError之后均可以持续发送接下来的事件，也可以不发送onComplete、但是onComplete和onError不可以同时存在并且唯一。下游接收到onComplete、onError之后不再继续接收。 Disposable可以简单理解成两根水管之间的一个开关。当调用他的dispose()方法时，它就会将两根水管切断，导致下游接收不到事件 ，但是上游会继续发送事件。 上游在切断水管之后依旧发送了3、4、onComplete事件，而下游只接收到了切断之前的事件 subscribe()有多个重载方法 subscribe() 不带任何参数，表示下游不关心上游发送了什么，发你的去吧 带有一个Consumer表示下游只关心onNext事件。 线程操控上下游默认是工作在同一线程中的。 1observable.subscribeOn(Schedulers.newThread()).observeOn(AndroidSchedulers.mainThread()).subscribe(consumer); subscribeOn() 指定的是上游发送事件的线程, observeOn() 指定的是下游接收事件的线程. 多次调用subscribeOn只有第一次生效 多次调用observerOn，每次调用下游都会切换一次线程 尽量使用RxJava内置的线程来使用，内部是线程池来维护效率比较高： Schedulers.io 代表io操作的线程，通常用于网络、读写文件等io密集型操作。 Schedulers.computation()代表CPU计算密集型操作，例如需要大量计算的操作 Schedulers.newThread()代表一个常规的新线程 AndroidSchedulers.mainThread代表Android的主线程 变换操作符Map将上游的事件通过指定的函数去变化，下游接收到的就是变化后的一个个事件了。 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return &quot;this is result&quot; + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); FlatMap上游每次发送一个事件，FlatMap就会创建一个新水管，发送转换之后的事件，不保证顺序 12345678910flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; final List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int j = 0; j &lt; 3; j++) &#123; list.add(&quot;i am value&quot; + j); &#125; return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS); &#125; &#125;) 延迟只是为了证明flatMap是无序的 ，如果需要有序的可以使用concatMap，用法与flatMap一模一样。 zip操作符通过一个函数将多个Observable结合到一起然后再发送 123456789101112131415161718192021222324252627282930313233 Observable.zip(observable, observable1, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, &quot;onNext: &quot; + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125; &#125;);&#125; 由zip引出的Backpressure概念： zip是用于组合两根水管，假如一根水管发送快，一根发送慢，那么发送快的势必需要等待，因此需要将数据缓存到一个类似水缸的地方。但是如果一直往水缸里发送数据，内存就会爆掉。Backpressure就是控制流量的 控制流量方案1：1234567891011121314Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; //无限循环发事件 emitter.onNext(i); &#125; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); Log.d(TAG, &quot;&quot; + integer); &#125; &#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android中的IPC机制]]></title>
    <url>%2F2017%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1.IPC简介IPC含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程 , Android中IPC通信的方式有很多，例如: Binder Scoket 这里面最有特色的就是Binder 2.Android中的多进程模式2.1开启多进程模式 Android中开启多线程模式非常的简单，只要在四大组件(Activity、Service、Receive、ContentProvider)的AndroidMeniFest中指定android:process属性。 android:process=&quot;com.ryg.chapter_2.remote&quot; android:process=&quot;:remote&quot; 上面两种写法是有区别的： ： 的含义是指在当前线程名前面附加当前的包名，这是一种简写的方法。并且以:开头的进程属于私有进程，其他应用的组件不可以和它跑在同一个进程中。 andoid:process=&quot;com.ryg.chapter_2.remote&quot;这是完整的写法，该写法的进程属于全局进程，其他应用可以通过共享ShareUid方式和它跑在同一个进程中。 2.2 多进程模式的运行机制一句话形容多进程： 当开启了多进程以后，各种奇怪的现象都出现了 分析：我们知道Android会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址控件，这就导致在不同虚拟机中访问同一个类的对象产生多份副本。 多进程会造成以下的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences的可靠性下降 Application会多次创建 以上是多进程所带来的问题，但是我们不能因为多进程有很多问题就不去正视他，为了解决这个问题，系统提供了很多跨进程通信方法： 通过Intent来传递数据 共享文件和sharedPerences 基于Binder的Message和AIDL Socket等等 为了更好的理解IPC机制，我们先来熟悉一些基础概念，比如：SerializableParacelabel 2.3.1 Serializable接口Serializable实现起来非常简单，几乎所有的工作都是系统完成的。如下代码：12345678 public class User implements Serializable &#123; private static final long serialVersionUID = 321112538042654820L; public int userId; public String userName; public boolean isMale;&#125; 使用AS的同学会发现serialVersionUID无法自动提示，这是因为Android Studio设置中忽略了这个，需要重新设置下 File–&gt;Settings–&gt;Editor–&gt;Inspections–&gt;Java–&gt;Serialization issues–&gt;Serializable class without ‘serialVersionUID’ 勾选中该选项即可。 进入实现了Serializable中的类，选中类名，Alt+Enter弹出提示，然后直接导入完成 如何进行对象的序列号和反序列化呢 123456789101112131415161718192021222324 User user = new User(0, &quot;jack&quot;, true); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cache.txt&quot;)); objectOutputStream.writeObject(user); objectOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;//反序列化过程 try &#123; ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;)); try &#123; User user1 = (User) inputStream.readObject(); inputStream.close(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 2.3.2 Parcelable接口 Parcelable也是一个接口，同样是实现这个接口就可以实现序列化和反序列化。下面是用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public class User implements Parcelable &#123; public int userId; public String userName; public boolean isMale; public Book mBook; public User(int userId, String userName, boolean isMale, Book book) &#123; this.userId = userId; this.userName = userName; this.isMale = isMale; mBook = book; &#125; protected User(Parcel in) &#123; userId = in.readInt(); userName = in.readString(); isMale = in.readByte() != 0; mBook = in.readParcelable(Book.class.getClassLoader()); &#125; public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(userId); dest.writeString(userName); dest.writeByte((byte) (isMale ? 1 : 0)); dest.writeParcelable(mBook, flags); &#125;&#125; 所有的工作AS都会有提示只需无脑CTRL ENTER。 那么两种序列化之间改如何选取呢？ Serializable是Java中的序列号接口，使用起来简单但是开销大 Parcelable是Android中的序列化方式，因此更适合在Android平台，缺点是使用起来稍微麻烦，但是效率很高。因此首选Parcelable 但是在以下两种情况下应选Serializable 将对象序列化到存储设备中 将对象序列化后通过网络传输 2.3.3 Binder]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo搭建个人博客]]></title>
    <url>%2F2017%2F07%2F25%2Fhow-to-get-hexo%2F</url>
    <content type="text"><![CDATA[前言很早就有搭建博客的想法，最近终于有时间，去网上去搜相关教程，结果各种坑，决定写一篇。 假设你已经拥有了GitHub以及ssh认证等，去gitHub新建一个仓库，仓库名必须为 yourusername.github.io 如： 创建完了之后先不用管他。 正式安装Hexo在安装Hexo之前需要安装Node.js，直接去官网download无脑安装即可。这里我们主要说Hexo。 首先创建一个文件夹存放hexo配置，如Blog。 记住在执行hexo指令前，必须是在刚才存放hexo配置的文件目录下，否则命令无效，所依我们一路cd 到刚才的Blog文件夹下 执行如下命令安装Hexo： sudo npm install -g hexo 初始化然后，执行init命令初始化hexo,命令： hexo init hexo的指令非常少而且简单，现在我们来测下hexo是否成功安装 hexo g 本地启动我们来预览调试 hexo s浏览器输入 http://localhost:4000 现在回到我们的github 找到你的仓库，yourusername.github.io 点击仓库的SETTING选项卡 下拉到GitHub Pages选项中，点击如下图按钮Choose theme 点击之后随便选个theme，随后关闭我们的GitHub. 配置Hexo进入我们的Blog文件夹，这里的根目录下有个_config.yml文件，这个叫做站点配置文件可以理解成全局的配置文件。 现在来设置这个配置文件 这里重点修改内容是整个配置文件的最下面的这么一段： deploy: type: git repo: git@github.com:fay77/fay77.github.io.git branch: master 需要注意的是所有的冒号后面都要加个空格，否则无效，repo后面跟的是ssh地址，http地址会有问题 然后执行命令： npm install hexo-deployer-git --save 到此为止基本配置都结束了，我们开始部署到gitHub上，执行命令： hexo deploy 然后再浏览器中输入http://fay77.github.io/ 就行了，我的github的账户叫fay77,把这个改成你github的账户名就行了 Notes每次部署都按以下三步来进行 hexo clean hexo g hexo d 域名绑定以上步骤生成的博客地址均以 xxx.github.io为地址的，你也可以更改这个地址，绑定你的域名。 购买域名我用的是dnspod，进入搜索你想要的域名，然后支付。这里很简单不多说。 点击 解析 进入 点击 添加记录 选A 这里的ping需要打开cmd执行命令 ping -t fay77github.io得到一串ip地址，复制并且粘贴到记录值一栏。 点击确定。 再次点击添加记录 选CNAME记录值这次填你的github.io那个地址就可以了。 GitHubPage绑定你的域名在blog文件下新建CNAME，里面填入你的域名。 然后执行命令 hexo g hexo d 大功告成。 访问你的域名就可以了。 多台电脑同时编写博客上面都完成之后你应该正在愉快的编写博客了，当你回家想写点什么，fuck博客的资料全在单位电脑咋办 利用分支解决多电脑同步博客的问题首先我们进入到已经git clone了xxx.github.io仓库了的文件夹中，命令行敲起来，墙裂推荐cmder命令行，wins下的cmd简直跟屎一样。 二话不说就是一个git pull更新master分支上的内容，随后创建本地分支hexo ，这个名字你可以随便取 git checkout -b hexo创建并且切换到我们本地的hexo分支下，我们要在这个分支下管理所有的博客资源文件，将我们上面，不对是很上面创建的Blog文件整个复制到hexo分支所在的文件夹目录下 执行git status 会发现blog文件下的东西显示未添加到git， 这里有个小坑 如果git提示某些文件无法add，我们只要进入那个文件下找到 .git 文件并且删除即可然后commit这些都是git常用指令了，不多说。 接下来就是提交blog整个文件到远端了 执行git push origin hexo:hexo 这里我将远端的分支也命名为hexo了，所以看起来有点变扭，建议命名为remote_hexo用以区分远端和本地。 到这一步基本就都ok了。 然后我们来看看有分支下的情况下如何更新博客的： 进入到git clone了的文件目录下，找到.md也就是你的博客文章，然后修改。 git add git commit git push origin hexo将修改的博文推送到远端你会发现修改的博客文章状态改变了 执行hexo g hexo d,hexo会自动将.md文章转成html等推送到远端的master分支。 建议去github将hexo分支设置为默认分支，这样我们只需要手动管理hexo分支即可，master就交给了hexo去自动管理了。]]></content>
  </entry>
</search>